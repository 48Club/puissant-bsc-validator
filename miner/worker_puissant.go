/*
	Copyright 2023 48Club

	This file is part of the puissant-bsc-validator library and is intended for the implementation of puissant services.
	Parts of the code in this file are derived from the go-ethereum library.
	No one is authorized to copy, modify, or publish this file in any form without permission from 48Club.
	Any unauthorized use of this file constitutes an infringement of copyright.
*/

package miner

import (
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core"
	"github.com/ethereum/go-ethereum/core/systemcontracts"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/log"
	"math/big"
	"time"
)

// generateParams wraps various of settings for generating sealing task.
type generateParams struct {
	timestamp   uint64            // The timestamp for sealing task
	forceTime   bool              // Flag whether the given timestamp is immutable or not
	parentHash  common.Hash       // Parent block hash, empty means the latest chain head
	coinbase    common.Address    // The fee recipient address for including transaction
	random      common.Hash       // The randomness generated by beacon chain, empty before the merge
	withdrawals types.Withdrawals // List of withdrawals to include in block.
	noTxs       bool              // Flag whether an empty block without any transaction is expected
}

type multiPackingWork struct {
	round  int
	income *big.Int
	work   *core.MinerEnvironment
	err    error
}

// makeEnv creates a new environment for the sealing block.
func (w *worker) makeEnv(parentRoot common.Hash, header *types.Header) (*core.MinerEnvironment, error) {
	topState, err := w.chain.StateAt(parentRoot)
	if err != nil {
		return nil, err
	}
	systemcontracts.UpgradeBuildInSystemContract(w.chainConfig, header.Number, topState)

	return &core.MinerEnvironment{
		Signer:   types.MakeSigner(w.chainConfig, header.Number, header.Time),
		Coinbase: header.Coinbase,
		GasPool:  core.CreateGasPool(nil, w.chain.Config(), header),
		State:    topState,
		Header:   header,
	}, nil
}

func pickTheMostProfitableWork(workList []*multiPackingWork) *multiPackingWork {
	var (
		bestWork   = workList[0]
		bestReward = workList[0].income
	)

	for _, eachWork := range workList {
		if eachWork.err == nil && eachWork.income.Cmp(bestReward) > 0 {
			bestWork, bestReward = eachWork, eachWork.income
		}
	}

	log.Info("pick the most profitable work", "bestRound", bestWork.round, "bestReward", bestReward)
	return bestWork
}

func repackingInterval(fillElapsed time.Duration, headerTime uint64) time.Duration {
	left := blockMiningTimeLeft(headerTime)
	if left <= fillElapsed {
		return 0
	}
	f := int64(left) / int64(fillElapsed)
	if f > 20 && left > 1000*time.Millisecond+fillElapsed {
		return 500 * time.Millisecond
	} else if f > 10 && left > 500*time.Millisecond+fillElapsed {
		return 200 * time.Millisecond
	} else if f > 5 && left > 300*time.Millisecond+fillElapsed {
		return 100 * time.Millisecond
	} else if f > 1 && left > 20*time.Millisecond+fillElapsed {
		return 20 * time.Millisecond
	}
	return 0
}

func blockMiningTimeLeft(headerTime uint64) time.Duration {
	return time.Until(time.Unix(int64(headerTime), 0))
}

//func (w *worker) sendMessage(text string, mute bool) {
//	if w.messengerBot == nil {
//		return
//	}
//
//	var msg = fmt.Sprintf("*%s:* %s\n\n_%s_", w.nodeAlias, text, time.Now().Format(time.DateTime))
//	msgBody := tgbotapi.NewMessage(w.messengerToID, msg)
//	msgBody.ParseMode = "markdown"
//	msgBody.DisableWebPagePreview = true
//	msgBody.DisableNotification = mute
//
//	if _, err := w.messengerBot.Send(msgBody); err != nil {
//		log.Error("message sending failed", "err", err)
//	}
//}
