/*
	Copyright 2023 48Club

	This file is part of the puissant-bsc-validator library and is intended for the implementation of puissant services.
	Parts of the code in this file are derived from the go-ethereum library.
	No one is authorized to copy, modify, or publish this file in any form without permission from 48Club.
	Any unauthorized use of this file constitutes an infringement of copyright.
*/

package miner

import (
	"context"
	"errors"
	"fmt"
	mapset "github.com/deckarep/golang-set/v2"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/math"
	"github.com/ethereum/go-ethereum/consensus"
	"github.com/ethereum/go-ethereum/consensus/misc"
	"github.com/ethereum/go-ethereum/consensus/parlia"
	"github.com/ethereum/go-ethereum/core"
	"github.com/ethereum/go-ethereum/core/systemcontracts"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/log"
	"github.com/ethereum/go-ethereum/params"
	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api"
	"math/big"
	"time"
)

// generateParams wraps various of settings for generating sealing task.
type generateParams struct {
	timestamp  uint64         // The timstamp for sealing task
	forceTime  bool           // Flag whether the given timestamp is immutable or not
	parentHash common.Hash    // Parent block hash, empty means the latest chain head
	coinbase   common.Address // The fee recipient address for including transaction
	random     common.Hash    // The randomness generated by beacon chain, empty before the merge
	noUncle    bool           // Flag whether the uncle block inclusion is allowed
	noExtra    bool           // Flag whether the extra field assignment is allowed
}

type multiPackingWork struct {
	round  int
	level  int
	income *big.Int
	work   *core.MinerEnvironment
	err    error
}

// prepareWork constructs the sealing task according to the given parameters,
// either based on the last chain head or specified parent. In this function
// the pending transactions are not filled yet, only the empty task returned.
func (w *worker) prepareWork(genParams *generateParams) (common.Hash, *types.Header, error) {
	w.mu.RLock()
	defer w.mu.RUnlock()

	// Find the parent block for sealing task
	parent := w.chain.CurrentBlock()
	if genParams.parentHash != (common.Hash{}) {
		parent = w.chain.GetBlockByHash(genParams.parentHash)
	}
	if parent == nil {
		return common.Hash{}, nil, fmt.Errorf("missing parent")
	}
	// Sanity check the timestamp correctness, recap the timestamp
	// to parent+1 if the mutation is allowed.
	timestamp := genParams.timestamp
	if parent.Time() >= timestamp {
		if genParams.forceTime {
			return common.Hash{}, nil, fmt.Errorf("invalid timestamp, parent %d given %d", parent.Time(), timestamp)
		}
		timestamp = parent.Time() + 1
	}
	// Construct the sealing block header, set the extra field if it's allowed
	num := parent.Number()
	header := &types.Header{
		ParentHash: parent.Hash(),
		Number:     num.Add(num, common.Big1),
		GasLimit:   core.CalcGasLimit(parent.GasLimit(), w.config.GasCeil),
		Time:       timestamp,
		Coinbase:   genParams.coinbase,
	}
	if !genParams.noExtra && len(w.extra) != 0 {
		header.Extra = w.extra
	}
	// Set the randomness field from the beacon chain if it's available.
	if genParams.random != (common.Hash{}) {
		header.MixDigest = genParams.random
	}
	// Set baseFee and GasLimit if we are on an EIP-1559 chain
	if w.chainConfig.IsLondon(header.Number) {
		header.BaseFee = misc.CalcBaseFee(w.chainConfig, parent.Header())
		if !w.chainConfig.IsLondon(parent.Number()) {
			parentGasLimit := parent.GasLimit() * params.ElasticityMultiplier
			header.GasLimit = core.CalcGasLimit(parentGasLimit, w.config.GasCeil)
		}
	}
	// Run the consensus preparation with the default or customized consensus engine.
	if err := w.engine.Prepare(w.chain, header); err != nil {
		log.Error("Failed to prepare header for sealing", "err", err)
		return common.Hash{}, nil, err
	}

	return parent.Root(), header, nil
}

// makeEnv creates a new environment for the sealing block.
func (w *worker) makeEnv(parentRoot common.Hash, header *types.Header) (*core.MinerEnvironment, error) {
	topState, err := w.chain.StateAt(parentRoot)
	if err != nil {
		return nil, err
	}
	systemcontracts.UpgradeBuildInSystemContract(w.chainConfig, header.Number, topState)

	return &core.MinerEnvironment{
		Signer:   types.MakeSigner(w.chainConfig, header.Number),
		Coinbase: header.Coinbase,
		GasPool:  core.CreateGasPool(nil, w.chain.Config(), header),
		State:    topState,
		Header:   header,
	}, nil
}

// commitWork generates several new sealing tasks based on the parent block
// and submit them to the sealer.
func (w *worker) commitWork(interruptCh chan int32, timestamp int64) {
	start := time.Now()

	// Set the coinbase if the worker is running or it's required
	var coinbase common.Address
	if w.isRunning() {
		if w.coinbase == (common.Address{}) {
			log.Error("Refusing to mine without etherbase")
			return
		}
		coinbase = w.coinbase // Use the preset address as the fee recipient
	}

	parentRoot, initHeader, err := w.prepareWork(&generateParams{timestamp: uint64(timestamp), coinbase: coinbase})
	if err != nil {
		log.Error(" 💡 prepare mining block failed", "err", err)
		return
	}

	var (
		workList  = make([]*multiPackingWork, 0, 20)
		pReporter = core.NewPuissantReporter()
	)

LOOP:
	for round := 0; round < math.MaxInt32; round++ {
		roundStart := time.Now()

		work, err := w.makeEnv(parentRoot, types.CopyHeader(initHeader))
		if err != nil {
			return
		}
		thisRound := &multiPackingWork{round: round, work: work, income: common.Big0}
		workList = append(workList, thisRound)

		timeLeft := blockMiningTimeLeft(work.Header.Time)
		if timeLeft <= 0 {
			log.Warn(" 📦 ⚠️ not enough time for this round, jump out",
				"round", round,
				"income", types.WeiToEther(thisRound.income),
				"elapsed", common.PrettyDuration(time.Since(roundStart)),
				"timeLeft", timeLeft,
			)
			break
		}

		// empty block at first round
		if round == 0 {
			log.Info(" 📦 packing", "round", round, "elapsed", common.PrettyDuration(time.Since(roundStart)))
			continue
		}

		pendingTxs, pendingPuissant, level := w.eth.TxPool().PendingTxsAndPuissant(work.Header.Time, parlia.IsHeaderInturn(work.Header))
		report, err := core.RunPuissantCommitter(
			timeLeft,
			work,
			pendingTxs,
			pendingPuissant,
			w.chain,
			w.chainConfig,
			w.eth.TxPool().DeletePuissantPackages,

			// TODO pull recent packed txs from api
			mapset.NewSet[common.Hash](),
		)
		pReporter.Update(report, round)
		thisRound.err = err
		thisRound.level = level
		thisRound.income = work.State.GetBalance(consensus.SystemAddress)

		roundElapsed := time.Since(roundStart)
		select {
		case signal, ok := <-interruptCh:
			if !ok {
				// should never be here, since interruptCh should not be read before
				log.Warn("commit transactions stopped unknown")
				return
			}
			if err := signalToErr(signal); errors.Is(err, errBlockInterruptedByNewHead) {
				log.Debug("commitWork abort", "err", err)
				return
			} else if errors.Is(err, errBlockInterruptedByTimeout) || errors.Is(err, errBlockInterruptedByOutOfGas) {
				// break the loop to get the best work
				log.Debug("commitWork finish", "reason", err)
				break LOOP
			}
		default:
		}

		roundInterval := repackingInterval(roundElapsed, work.Header.Time)

		log.Info(" 📦 packing",
			"round", round,
			"txs", work.PackedTxs.Len(),
			"triedPuissant", len(report),
			"income", types.WeiToEther(thisRound.income),
			"elapsed", common.PrettyDuration(roundElapsed),
			"timeLeft", blockMiningTimeLeft(work.Header.Time),
			"interval", common.PrettyDuration(roundInterval),
			"err", thisRound.err,
		)

		if roundInterval > 0 {
			ctx, cancel := context.WithTimeout(context.Background(), roundInterval)
			go func() {
				for {
					select {
					case <-ctx.Done():
						return
					case <-interruptCh:
						cancel()
					}
				}
			}()
			<-ctx.Done()
			if errors.Is(ctx.Err(), context.Canceled) {
				log.Info(" ⚠️ jump out due to interruption")
				return
			}
		} else {
			// no time for another round, commit now
			break LOOP
		}
	}

	bestWork := pickTheMostProfitableWork(workList)
	w.commit(bestWork.work, w.fullTaskHook, true, start)

	go pReporter.Done(bestWork.round, initHeader.Number.Uint64(), bestWork.income, w.sendMessage, w.engine.SignText)
}

func pickTheMostProfitableWork(workList []*multiPackingWork) *multiPackingWork {
	var (
		pickLevel         int
		bestMatchedWork   *multiPackingWork
		bestMatchedReward = big.NewInt(0)
		bestWork          = workList[0]
		bestReward        = workList[0].income
	)
	for _, eachWork := range workList {
		if eachWork.level > pickLevel {
			pickLevel = eachWork.level
		}
	}

	for _, eachWork := range workList {
		if eachWork.err == nil && eachWork.income.Cmp(bestReward) > 0 {
			bestWork, bestReward = eachWork, eachWork.income
		}
		if eachWork.level == pickLevel && eachWork.err == nil && eachWork.income.Cmp(bestMatchedReward) > 0 {
			bestMatchedWork, bestMatchedReward = eachWork, eachWork.income
		}
	}

	if bestMatchedWork != nil {
		log.Info("pick the most profitable work", "bestRound", bestMatchedWork.round, "bestReward", bestMatchedReward)
		return bestMatchedWork
	}
	log.Info("pick the most profitable work", "bestRound", bestWork.round, "bestReward", bestReward)
	return bestWork
}

func repackingInterval(fillElapsed time.Duration, headerTime uint64) time.Duration {
	left := blockMiningTimeLeft(headerTime)
	if left <= fillElapsed {
		return 0
	}
	f := int64(left) / int64(fillElapsed)
	if f > 20 && left > 1000*time.Millisecond+fillElapsed {
		return 500 * time.Millisecond
	} else if f > 10 && left > 500*time.Millisecond+fillElapsed {
		return 200 * time.Millisecond
	} else if f > 5 && left > 300*time.Millisecond+fillElapsed {
		return 100 * time.Millisecond
	} else if f > 1 && left > 20*time.Millisecond+fillElapsed {
		return 20 * time.Millisecond
	}
	return 0
}

func blockMiningTimeLeft(headerTime uint64) time.Duration {
	return time.Until(time.Unix(int64(headerTime), 0))
}

func (w *worker) sendMessage(text string, mute bool) {
	if w.messengerBot == nil {
		return
	}

	var msg = fmt.Sprintf("*%s:* %s\n\n_%s_", w.nodeAlias, text, time.Now().Format(time.DateTime))
	msgBody := tgbotapi.NewMessage(w.messengerGroupID, msg)
	msgBody.ParseMode = "markdown"
	msgBody.DisableWebPagePreview = true
	msgBody.DisableNotification = mute

	if _, err := w.messengerBot.Send(msgBody); err != nil {
		log.Error("message sending failed", "err", err)
	}
}
